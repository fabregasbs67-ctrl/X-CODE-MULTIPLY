<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <!-- Viewport s√≥lido para iOS (teclado, safe areas, notch) -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1"/>
  <title>X Code Chat ‚Äî Official</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet"/>

  <style>
  /* =========================================================
     PALETA Y TOKENS
  ========================================================= */
  :root{
    --bg:#000; --fg:#fff; --muted:#cfcfcf; --line:#2a2a2a; --gold:#D0A500;
    --accent:#00ffbb; --danger:#ff5a5a;

    /* Altura de viewport ‚Äúreal‚Äù (se actualiza por JS en iOS) */
    --vh: 1vh;
  }

  /* =========================================================
     RESET + BASE APP
     - Evitamos scroll del documento.
     - Toda la app vive en .wrap y hace su propio layout.
  ========================================================= */
  *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
  html,body{ height:100%; }
  html{ background:var(--bg); }

  body{
    margin:0; color:var(--fg); background:var(--bg);
    font-family:Inter,system-ui,Roboto,Arial,sans-serif;

    /* Clave: el documento NO hace scroll. */
    overflow:hidden;

    /* Altura bloqueada a 100% del viewport visual (iOS safe) */
    height:calc(var(--vh) * 100);
    min-height:calc(var(--vh) * 100);

    /* Evita rebote/overscroll global en iOS */
    overscroll-behavior:none;
    touch-action:manipulation;
  }

  /* Contenedor principal ‚Äúapp-like‚Äù.
     flex: column + min-height:0 => hijos pueden hacer overflow. */
  .wrap{
    max-width:980px; width:100%;
    margin:0 auto; padding:12px;
    display:flex; flex-direction:column; gap:12px;

    /* Altura plena con safe-areas */
    height:100%;
    padding-top: calc(12px + env(safe-area-inset-top));
    padding-bottom: calc(12px + env(safe-area-inset-bottom));

    /* CR√çTICO: permitir overflow en hijos (chat/messages) */
    min-height:0;
  }

  /* =========================================================
     COMPONENTES GENERALES
  ========================================================= */
  .card{ background:#0b0b0b; border:1px solid var(--line); border-radius:16px; padding:14px }
  .header{ display:flex; align-items:center; justify-content:space-between; gap:10px }
  .brand{ display:flex; align-items:center; gap:10px }
  .brandLogoBox{
    width:32px; height:32px; border-radius:8px; display:grid; place-items:center;
    background:transparent; border:0; overflow:hidden;
  }
  .brandLogo{
    width:32px; height:32px; display:block; object-fit:contain; image-rendering:auto;
  }
  .ttl{ font-weight:700; font-size:18px }  /* compacto */
  .sub{ font-size:12px; color:var(--muted) } /* compacto */
  .row{ display:flex; align-items:center; gap:8px; flex-wrap:wrap }
  .btn{ appearance:none; border:1px solid #fff; background:#fff; color:#000; border-radius:10px; padding:8px 12px; font-weight:600; cursor:pointer; font-size:14px }
  .btn.ghost{ background:transparent; color:#fff }
  .btn.danger{ border-color:var(--danger); color:var(--danger); background:transparent }
  .btn.sm{ padding:6px 8px; font-size:12px; border-radius:8px }
  .field{ display:flex; align-items:center; gap:8px; border:1px solid var(--line); border-radius:10px; padding:8px; background:#0a0a0a }
  .field input,.field select{ flex:1; background:transparent; border:none; outline:none; color:var(--fg); font-size:15px }
  .eye{ cursor:pointer; user-select:none }
  .hint{ color:var(--muted); font-size:12px }

  .toast{
    position:fixed; left:50%; transform:translateX(-50%); bottom:12px;
    background:#111; border:1px solid var(--line); color:#fff;
    padding:8px 12px; border-radius:10px; display:none; z-index:1000; font-size:13px
  }
  .toast.show{ display:block }

  /* =========================================================
     LOGIN
  ========================================================= */
  .login{ max-width:700px; margin:4svh auto 0; display:flex; flex-direction:column; gap:8px }

  /* =========================================================
     GRID PRINCIPAL (ADMIN + CHAT)
     min-height:0 => permite scroll interno en .messages
  ========================================================= */
  .chatGrid{
    display:flex; gap:12px; align-items:flex-start;
    flex:1 1 auto; min-height:0;
  }

  /* =========================================================
     PANEL ADMIN
  ========================================================= */
  .adminPane{
    display:none; flex:0 0 320px; gap:10px; flex-direction:column;
    min-height:0;
  }
  .adminTabs{ display:flex; gap:6px }
  .tab{ padding:6px 10px; border:1px solid var(--line); border-radius:8px; background:#0f0f0f; cursor:pointer; font-size:13px }
  .tab.active{ outline:1px solid var(--gold) }
  .tabPanel{ display:none; gap:10px; flex-direction:column; min-height:0 }
  .tabPanel.show{ display:flex }
  .list{ border:1px dashed var(--line); border-radius:10px; padding:8px; max-height:260px; overflow:auto }
  .tag{ display:inline-block; border:1px solid #3a3a3a; border-radius:999px; padding:2px 8px; font-size:12px }
  .ok{ color:#00d38f; border-color:#00d38f }
  .bad{ color:#ff6a6a; border-color:#ff6a6a }
  .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; border:1px solid #555; margin-left:6px }
  .dot.green{ background:#00d38f; border-color:#00d38f }
  .dot.orange{ background:#ffb020; border-color:#ffb020 }
  .dot.red{ background:#ff5a5a; border-color:#ff5a5a }

  /* =========================================================
     CHAT
     - Header + Composer fijos DENTRO de la tarjeta (no del viewport).
     - Zona de mensajes con scroll interno y momentum en iOS.
  ========================================================= */
  .chatCard{
    flex:1 1 auto; display:flex; flex-direction:column; gap:8px;
    min-height:0;
  }

  .messages{
    flex:1 1 auto; min-height:0;
    overflow-y:auto;
    -webkit-overflow-scrolling:touch; /* momentum iOS */
    overscroll-behavior:contain;      /* no arrastra el body */
    scroll-behavior:smooth;

    padding:10px 10px 12px;
    border:1px solid var(--line); border-radius:12px;
    background:#0f0f0f;
    display:flex; flex-direction:column; gap:8px;
  }
  .messages::-webkit-scrollbar{ width:6px }
  .messages::-webkit-scrollbar-thumb{ background:#555; border-radius:6px }

  .msg{ max-width:92%; padding:8px 10px; border:1px solid #3a3a3a; border-radius:12px; background:#101010; white-space:pre-wrap; word-break:break-word; font-size:15px }
  .msg.me{ margin-left:auto; background:#141414; border-color:#555 }
  .msg .by{ font-size:12px; color:#9bd; opacity:.85; margin-bottom:2px }
  .msg .meta{ margin-top:4px; font-size:11px; color:#9a9a9a }
  .msg.sys{ opacity:.85; border-style:dashed }

  .composer{
    display:flex; gap:6px; align-items:center;
    border-top:1px solid var(--line); padding:6px; background:#080808;
    border-radius:12px;
  }
  .composer .field{ flex:1 }

  @media (max-width:820px){
    .chatGrid{ flex-direction:column }
    .adminPane{ width:100% }
  }

  /* =========================================================
     MODAL PIN
  ========================================================= */
  .backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.7); display:none; align-items:center; justify-content:center; z-index:2000; padding:16px }
  .backdrop.show{ display:flex!important }
  .modal{ background:#101010; border:1px solid var(--line); padding:18px 20px; border-radius:14px; width:min(420px,92vw); text-align:center; box-shadow:0 10px 28px rgba(0,0,0,.35) }
  .modal h3{ margin:0 0 8px 0; color:var(--gold) }
  .modal p{ margin:0 0 10px 0; color:#ddd }
  .modal .actions{ display:flex; gap:8px; justify-content:center }
  kbd{ font-family:monospace; border:1px solid #333; border-radius:6px; padding:1px 6px; background:#0a0a0a }
  </style>
</head>

<body>
  <div class="wrap" id="appWrap">
    <!-- ================= HEADER (compacto, con logo PNG) ================ -->
    <div class="card header">
      <div class="brand">
        <span class="brandLogoBox" aria-hidden="true">
          <!-- Solo imagen PNG, sin c√≠rculos ni SVGs -->
          <img id="brandLogo" class="brandLogo" src="/logo/logo.png" alt="Logo"/>
        </span>
        <div>
          <div class="ttl">X Code Chat ‚Äî Official</div>
          <div class="sub">
            Sala: <b id="roomHdr">Sala de Prueba</b>
            ¬∑ <span class="sub">Usuario #<b id="meIdHdr">‚Äî</b></span>
          </div>
        </div>
      </div>
      <div class="row">
        <span class="sub">Estado</span><span id="statusDot" class="dot"></span>
        <button id="logoutBtn" class="btn ghost" style="display:none">Salir</button>
      </div>
    </div>

    <!-- ========================= LOGIN ========================= -->
    <div id="loginCard" class="card login">
      <div class="hint">
        Acceso con <b>n√∫mero</b> y <b>PIN</b>. Si tu entrada est√° en la lista oficial,
        la primera vez se genera tu PIN y se muestra. Usuario <b>0</b> es organizador.
      </div>
      <div class="field"><input id="numInput" type="number" inputmode="numeric" placeholder="Tu n√∫mero (ej. 70)"/></div>
      <div class="field"><input id="pinInput" type="password" inputmode="numeric" placeholder="Tu PIN"/><span id="togglePin" class="eye">üëÅÔ∏è</span></div>
      <div class="row"><button id="loginBtn" class="btn">Entrar</button><div id="loginMsg" class="hint"></div></div>
      <div class="hint">Privado: escribe <kbd>@n√∫mero</kbd> al inicio (ej. <kbd>@120 hola</kbd>).</div>
    </div>

    <!-- ================ GRID PRINCIPAL (ADMIN + CHAT) =================== -->
    <div class="chatGrid" id="mainGrid" style="display:none">
      <!-- --------- PANEL ADMIN (solo organizador) --------- -->
      <aside id="adminPane" class="card adminPane">
        <div class="sub" style="font-weight:600">Panel del organizador</div>

        <!-- Tabs -->
        <div class="adminTabs">
          <div id="tabRooms" class="tab active">Salas</div>
          <div id="tabUsers" class="tab">Usuarios</div>
        </div>

        <!-- Panel: Salas -->
        <div id="panelRooms" class="tabPanel show">
          <div class="row">
            <div class="field" style="flex:1"><input id="roomInput" placeholder="Sala actual‚Ä¶"/></div>
            <button id="roomUseBtn" class="btn sm">Usar</button>
            <button id="btnReloadRooms" class="btn sm ghost">Recargar</button>
          </div>
          <div class="row">
            <div class="field" style="flex:1"><input id="newRoomName" placeholder="Nueva sala‚Ä¶"/></div>
            <button id="btnCreateRoom" class="btn sm">Crear sala</button>
          </div>
          <div id="roomsList" class="list"></div>
        </div>

        <!-- Panel: Usuarios -->
        <div id="panelUsers" class="tabPanel">
          <div class="row">
            <div class="field" style="flex:1;max-width:220px"><input id="userNumber" type="number" placeholder="N√∫mero (ej. 8)"/></div>
            <button id="btnCreateUser" class="btn sm">Crear</button>
            <button id="btnActivateUser" class="btn sm">Activar</button>
            <button id="btnDeactivateUser" class="btn sm danger">Desactivar</button>
            <button id="btnDeleteUser" class="btn sm danger">Eliminar</button>
          </div>
          <div class="sub">Conectados: <b id="countConn">0</b></div>
          <div id="usersList" class="list"></div>
        </div>
      </aside>

      <!-- ----------------- CHAT (scroll interno) ----------------- -->
      <section id="chatCard" class="card chatCard">
        <div id="messages" class="messages" aria-label="Mensajes"></div>

        <div class="composer" id="composer">
          <div class="field"><input id="msgInput" type="text" placeholder="Mensaje‚Ä¶  ¬∑  Privado con @n√∫mero" autocomplete="off" maxlength="400"/></div>
          <button id="sendBtn" class="btn">Enviar</button>
        </div>

        <div class="hint">Remitente visible: <b>Usuario #<span id="meId">?</span></b></div>
      </section>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast" class="toast"></div>

  <!-- Modal PIN (primera vez) -->
  <div id="pinBack" class="backdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>üîê Tu PIN</h3>
      <p id="pinText" style="font-size:1.4em;font-weight:800;color:var(--accent)">0000</p>
      <small style="opacity:.8">Se ha copiado al portapapeles</small>
      <div class="actions" style="margin-top:10px"><button id="pinOk" class="btn">Entendido</button></div>
    </div>
  </div>

  <!-- =========================================================
       APP SCRIPT (Firebase + l√≥gica)
       NOTA: Pega tu firebaseConfig de PRODUCCI√ìN donde indico.
  ==========================================================-->
  <script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
  import { getDatabase, ref, get, set, update, onValue, off, remove } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-database.js";

  /* ===== Firebase (PRODUCCI√ìN) =====
     ‚ö†Ô∏è MUY IMPORTANTE: pega aqu√≠ exactamente tu configuraci√≥n
     ACTUAL de producci√≥n (la misma que ya usas en chat.x-code.es).
     No cambies nombres de propiedades.
  */
  const firebaseConfig = {
    /* ‚Üê Pega aqu√≠ tu config de PRODUCCI√ìN (apiKey, authDomain, databaseURL, etc.) */
    /* EJEMPLO:
    apiKey: "XXXXXXXXXXXX",
    authDomain: "tu-proy.firebaseapp.com",
    databaseURL: "https://tu-proy-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "tu-proy",
    storageBucket: "tu-proy.appspot.com",
    messagingSenderId: "000000000000",
    appId: "1:000000000000:web:aaaaaaaaaaaaaaaaaaaaaa"
    */
  };

  /* ===== Config app ===== */
  const ENTRY_WHITELIST_PATHS = ["entradas","tickets"]; // whitelist
  const DEFAULT_ROOM = "Sala de Prueba";
  const ADMIN_PASS = "131215";
  const LS_LAST_ROOM = "xcode:lastRoom";
  const LS_SESSION   = "xcode:session";

  /* ===== Init ===== */
  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  /* ===== DOM ===== */
  const $ = (q)=>document.querySelector(q);
  const appWrap=$("#appWrap");
  const roomHdr=$("#roomHdr"), statusDot=$("#statusDot"), meIdHdr=$("#meIdHdr");
  const loginCard=$("#loginCard"), mainGrid=$("#mainGrid"), logoutBtn=$("#logoutBtn");
  const numInput=$("#numInput"), pinInput=$("#pinInput"), loginBtn=$("#loginBtn"), togglePin=$("#togglePin");
  const messages=$("#messages"), msgInput=$("#msgInput"), sendBtn=$("#sendBtn"), meIdSpan=$("#meId");
  const toastEl=$("#toast"), composerEl=$("#composer");
  const pinBack=$("#pinBack"), pinText=$("#pinText"), pinOk=$("#pinOk");
  const brandLogo=$("#brandLogo");

  /* Admin DOM */
  const adminPane=$("#adminPane");
  const tabRooms=$("#tabRooms"), tabUsers=$("#tabUsers");
  const panelRooms=$("#panelRooms"), panelUsers=$("#panelUsers");
  const roomInput=$("#roomInput"), roomUseBtn=$("#roomUseBtn"), btnReloadRooms=$("#btnReloadRooms");
  const newRoomName=$("#newRoomName"), btnCreateRoom=$("#btnCreateRoom"), roomsList=$("#roomsList");
  const userNumber=$("#userNumber"), btnCreateUser=$("#btnCreateUser"), btnActivateUser=$("#btnActivateUser"),
        btnDeactivateUser=$("#btnDeactivateUser"), btnDeleteUser=$("#btnDeleteUser"),
        usersList=$("#usersList"), countConn=$("#countConn");

  /* ===== Helpers ===== */
  const toast=(t,ms=2400)=>{ toastEl.textContent=t; toastEl.classList.add("show"); clearTimeout(window.__t); window.__t=setTimeout(()=>toastEl.classList.remove("show"),ms); };
  togglePin.onclick=()=> pinInput.type = (pinInput.type==="password" ? "text" : "password");
  const hhmm=(ts)=>new Date(ts||Date.now()).toLocaleTimeString('es-ES',{hour:'2-digit',minute:'2-digit'});
  const newPIN=()=> String(Math.floor(1000+Math.random()*9000));
  const timeAgo=(ts)=>{ if(!ts) return "‚Äî"; const s=Math.floor((Date.now()-ts)/1000); if(s<60) return `${s}s`; const m=Math.floor(s/60); if(m<60) return `${m}m`; return `${Math.floor(m/60)}h`; };
  const roomRef=(room,path)=> ref(db, `rooms/${room}/${path}`);
  const currentRoomRef=(path)=> roomRef(session.room, path);

  /* Estado y suscripciones */
  let session={ room: DEFAULT_ROOM, num:null, isAdmin:false };
  let detachMsgs=null, detachUsers=null, usersCache={}, usersTimer=null, statusTimer=null;
  let currentRoomCache = null; // cache de la sala global

  /* ===== Responsivo iOS ‚Äúreal-vh‚Äù + teclado =====
     - Fija --vh al alto de visualViewport.
     - Recalcula en resize/scroll (iOS teclado).
     - Bloquea scroll del body; solo scrollea .messages
  */
  const vv = window.visualViewport || null;
  function setRealVh(){
    const h = vv ? vv.height : window.innerHeight;
    document.documentElement.style.setProperty('--vh', `${h*0.01}px`);
  }
  setRealVh();
  window.addEventListener('resize', setRealVh);
  if(vv){
    vv.addEventListener('resize', setRealVh);
    vv.addEventListener('scroll', setRealVh);
  }

  // Evita que el body reciba scroll (iOS ‚Äúbounce‚Äù)
  document.addEventListener('touchmove',(e)=>{
    const p = e.target.closest('.messages');
    if(!p){ e.preventDefault(); }
  }, {passive:false});

  // Asegurar que el mensaje visible no queda oculto tras teclado
  function snapToBottom(){
    messages.scrollTop = messages.scrollHeight;
  }

  /* ===== Persistencia (localStorage) ===== */
  const saveLastRoom=(name)=>{ try{ localStorage.setItem(LS_LAST_ROOM, name) }catch{} };
  const loadLastRoom=()=>{ try{ return localStorage.getItem(LS_LAST_ROOM) || DEFAULT_ROOM }catch{ return DEFAULT_ROOM } };
  function saveSession(){
    try{
      localStorage.setItem(LS_SESSION, JSON.stringify({
        num:session.num, pin:pinInput.value||"", room:session.room, isAdmin:!!session.isAdmin
      }));
    }catch{}
  }
  function clearSession(){ try{ localStorage.removeItem(LS_SESSION) }catch{} }
  function loadSession(){ try{ const s=localStorage.getItem(LS_SESSION); return s?JSON.parse(s):null }catch{ return null } }

  /* ===== Sala global (settings/currentRoom) ===== */
  async function getCurrentRoomOnce(){
    const snap = await get(ref(db,'settings/currentRoom'));
    return snap.exists() ? (snap.val()||DEFAULT_ROOM) : DEFAULT_ROOM;
  }
  function listenGlobalRoom(){
    const r = ref(db,'settings/currentRoom');
    onValue(r,(snap)=>{
      const room = snap.exists() ? (snap.val()||DEFAULT_ROOM) : DEFAULT_ROOM;
      currentRoomCache = room;
      // Solo usuarios normales obedecen el valor global (admin puede estar cambiando)
      if(!session.isAdmin && session.num!==0){
        session.room = room;
        roomHdr.textContent = room;
        roomInput.value     = room;
        saveLastRoom(room);
      }
    });
  }
  async function setGlobalRoom(roomName){
    try{ await set(ref(db,'settings/currentRoom'), roomName); }
    catch{}
  }

  /* ===== Tabs admin ===== */
  function setActiveTab(which){
    tabRooms.classList.remove("active"); tabUsers.classList.remove("active");
    panelRooms.classList.remove("show"); panelUsers.classList.remove("show");
    if(which==="rooms"){ tabRooms.classList.add("active"); panelRooms.classList.add("show"); }
    else { tabUsers.classList.add("active"); panelUsers.classList.add("show"); }
  }
  tabRooms.onclick=()=>setActiveTab("rooms");
  tabUsers.onclick=()=>setActiveTab("users");

  /* ===== Whitelist ===== */
  async function isEntryAllowed(n){
    for(const base of ENTRY_WHITELIST_PATHS){
      const s=await get(ref(db, `${base}/${n}`));
      if(s.exists()){
        const d=s.val()||{}; const estado=d.estado? String(d.estado).toLowerCase(): null;
        if(estado==="activa"||estado==="activo"||d.active===true||d.active==="true") return true;
      }
    }
    return false;
  }

  /* Normaliza users/{n}/{n} -> users/{n} (compatibilidad) */
  async function normalizeUserNode(room,n){
    const base = `rooms/${room}/users/${n}`;
    const uRef = ref(db, base);
    const nestedRef = ref(db, `${base}/${n}`);
    const uSnap = await get(uRef);
    const nestedSnap = await get(nestedRef);
    if(nestedSnap.exists()){
      const nested = nestedSnap.val();
      const already = uSnap.exists()? uSnap.val() : null;
      if(!already || !already.pin){
        await set(uRef, nested);
        await set(nestedRef, null);
        return (await get(uRef)).val();
      }
    }
    return uSnap.exists()? uSnap.val() : null;
  }

  /* ===== LOGIN ===== */
  async function doLogin(){
    const nStr=(numInput.value||"").trim();
    if(!/^\d+$/.test(nStr)){ toast("Introduce tu n√∫mero"); return; }
    const n=Number(nStr); const pTyped=(pinInput.value||"").trim();

    loginBtn.disabled=true;

    // Cabecera con la sala global (si existe)
    try{
      const globalRoom = currentRoomCache || await getCurrentRoomOnce();
      session.room = globalRoom || loadLastRoom() || DEFAULT_ROOM;
      roomHdr.textContent=session.room; roomInput.value=session.room; saveLastRoom(session.room);
    }catch{
      session.room = loadLastRoom() || DEFAULT_ROOM;
      roomHdr.textContent=session.room; roomInput.value=session.room;
    }

    try{
      if(n===0){
        const pass=prompt("Contrase√±a de organizador:");
        if(pass!==ADMIN_PASS) throw new Error("Contrase√±a incorrecta.");
        session.num=0; session.isAdmin=true;
        enterChat(true); saveSession(); return;
      }

      const allowed = await isEntryAllowed(n);
      if(!allowed) throw new Error("Tu n√∫mero no est√° en la lista oficial.");

      let data = await normalizeUserNode(session.room, n);
      if(!data || !data.pin){
        // Primera vez: generamos PIN y lo mostramos
        const pin=newPIN();
        await set(currentRoomRef(`users/${n}`), { pin, active:true, connected:false, created:Date.now(), updated:Date.now() });
        pinText.textContent=pin;
        pinBack.classList.add("show"); pinBack.style.display="flex"; pinBack.setAttribute("aria-hidden","false");
        navigator.clipboard.writeText(pin).catch(()=>{});
        pinOk.onclick=()=>{ pinBack.classList.remove("show"); pinBack.style.display="none"; pinBack.setAttribute("aria-hidden","true"); toast("Introduce tu PIN y pulsa Entrar"); };
        return;
      }
      if(!pTyped) throw new Error("Introduce tu PIN");
      if(String(data.pin)!==String(pTyped)) throw new Error("PIN incorrecto");

      await update(currentRoomRef(`users/${n}`), { connected:true, updated:Date.now() });
      session.num=n; session.isAdmin=false; enterChat(false); saveSession();
    }catch(err){ toast(err.message||"No se pudo iniciar sesi√≥n"); }
    finally{ loginBtn.disabled=false; }
  }
  loginBtn.onclick=doLogin;
  numInput.onkeydown=(e)=>{ if(e.key==="Enter") doLogin(); };
  pinInput.onkeydown=(e)=>{ if(e.key==="Enter") doLogin(); };

  /* ===== ENTER APP ===== */
  function enterChat(isAdmin){
    // UI
    loginCard.style.display="none";
    mainGrid.style.display="flex";
    logoutBtn.style.display="inline-flex";
    meIdSpan.textContent=session.num;
    meIdHdr.textContent = session.num ?? '‚Äî';

    // Sala visible
    roomHdr.textContent=session.room; roomInput.value=session.room; saveLastRoom(session.room);

    // Admin
    if(isAdmin || session.num===0 || session.isAdmin){
      adminPane.style.display="flex";
      reloadRooms();
      loadUsersRealtime();
      if(!usersTimer) usersTimer=setInterval(updateUsersAgo,30000);
      if(!statusTimer) statusTimer=setInterval(pingStatusOnce,10000);
      setTimeout(pingStatusOnce,600);
    }else{
      adminPane.style.display="none";
    }

    // Mensajes
    attachMessages();

    // Autoscroll + foco
    setTimeout(()=>{ msgInput?.focus(); snapToBottom(); }, 30);
  }

  /* ===== LOGOUT ===== */
  async function doLogout(){
    try{ if(session.num>0){ await update(currentRoomRef(`users/${session.num}`), { connected:false, updated:Date.now() }); } }catch{}

    if(detachMsgs){ detachMsgs(); detachMsgs=null; }
    if(detachUsers){ detachUsers(); detachUsers=null; }
    if(usersTimer){ clearInterval(usersTimer); usersTimer=null; }
    if(statusTimer){ clearInterval(statusTimer); statusTimer=null; }

    clearSession(); // mantenemos LS_LAST_ROOM

    mainGrid.style.display="none"; logoutBtn.style.display="none"; adminPane.style.display="none";
    loginCard.style.display="flex";
    messages.innerHTML=""; msgInput.value="";
    // al volver a login, reflejamos la sala global si se conoce
    session={ room: currentRoomCache || loadLastRoom() || DEFAULT_ROOM, num:null, isAdmin:false };
    roomHdr.textContent=session.room; roomInput.value=session.room; meIdHdr.textContent='‚Äî';
  }
  logoutBtn.onclick=doLogout;

  /* ===== CHAT ===== */
  function renderMsg(m){
    if(m.sys && session.num!==0) return;
    if(m.to && !(m.to===session.num || m.from===session.num || session.num===0)) return;
    const div=document.createElement("div");
    div.className="msg"+(m.from===session.num?" me":"")+(m.sys?" sys":"");
    div.innerHTML=`<div class="by">${m.from===0?"Organizador":"Usuario #"+m.from}${m.to? " ‚Üí #"+m.to:""}</div>
                   <div>${m.text||""}</div>
                   <div class="meta">${hhmm(m.ts)||""}</div>`;
    messages.appendChild(div);
  }

  function attachMessages(){
    if(detachMsgs){ detachMsgs(); detachMsgs=null; }
    const r = currentRoomRef("messages");
    const handler = (snap)=>{
      messages.innerHTML="";
      const val=snap.val()||{};
      const arr=Object.values(val).sort((a,b)=>(a.ts||0)-(b.ts||0));
      arr.forEach(renderMsg);
      snapToBottom();
    };
    onValue(r, handler);
    detachMsgs = ()=> off(r, "value", handler);
  }

  async function sendMessage(){
    const raw=(msgInput.value||"").trim(); if(!raw) return;
    const id=Date.now()+"_"+Math.random().toString(36).slice(2,8);
    let payload={ from: session.num, text: raw, ts: Date.now() };
    const m = raw.match(/^@(\d+)\s+(.+)/);
    if(m){ payload.to = Number(m[1]); payload.text = m[2]; }
    await set(currentRoomRef(`messages/${id}`), payload);
    msgInput.value="";
    snapToBottom();
  }
  sendBtn.onclick = sendMessage;
  msgInput.onkeydown = (e)=>{ if(e.key==="Enter"){ e.preventDefault(); sendMessage(); } };

  /* ===== Indicador de estado (solo admin) ===== */
  async function pingStatusOnce(){
    if(session.num!==0) return;
    const id="PING_"+Date.now()+"_"+Math.random().toString(36).slice(2,5);
    const msg={ from:0, text:`[PING ${id}]`, ts:Date.now(), sys:true };
    const start=performance.now(); let done=false;
    const r=currentRoomRef("messages");
    const handler=(snap)=>{
      if(done) return;
      const val=snap.val()||{};
      const found=Object.values(val).some(m=> m && m.sys && typeof m.text==="string" && m.text.includes(id));
      if(found){
        done=true; off(r,"value",handler);
        const ms=performance.now()-start;
        statusDot.className="dot "+(ms<2000? "green" : "orange");
        setTimeout(()=> remove(currentRoomRef(`messages/${id}`)).catch(()=>{}), 2000);
      }
    };
    onValue(r, handler);
    await set(currentRoomRef(`messages/${id}`), msg);
    setTimeout(()=>{ if(!done){ off(r,"value",handler); statusDot.className="dot red"; remove(currentRoomRef(`messages/${id}`)).catch(()=>{}); } }, 2800);
  }

  /* ===== Gestor de salas ===== */
  const roomMetaRef=(n)=>ref(db,`roomsMeta/${n}`);
  const roomIndexRef=(n)=>ref(db,`rooms_index/${n}`);

  async function reloadRooms(){
    roomsList.innerHTML="<div class='sub'>Cargando salas‚Ä¶</div>";
    const snap=await get(ref(db,"roomsMeta"));
    roomsList.innerHTML="";
    const data=snap.val()||{};
    const names=Object.keys(data).sort((a,b)=> a.localeCompare(b));
    if(!names.length){ roomsList.innerHTML="<div class='sub'>No hay salas todav√≠a.</div>"; return; }
    names.forEach(name=>{
      const row=document.createElement("div"); row.className="row";
      const mark = name===session.room ? " ¬∑ <span class='tag ok'>en uso</span>" : "";
      row.innerHTML = `<b>${name}</b>${mark}
        <button class="btn sm" data-act="use">Usar</button>
        <button class="btn sm ghost" data-act="rename">Renombrar</button>
        <button class="btn sm danger" data-act="delete">Eliminar</button>`;
      row.querySelector("[data-act=use]").onclick=()=>{ roomInput.value=name; roomUseBtn.click(); };
      row.querySelector("[data-act=rename]").onclick=async()=>{
        const newName=prompt("Nuevo nombre para la sala:", name);
        if(!newName||newName===name) return;
        const exists=await get(roomMetaRef(newName)); if(exists.exists()) return toast("Ya existe una sala con ese nombre");
        if(!confirm(`Renombrar "${name}" a "${newName}"?`)) return;
        await set(roomMetaRef(newName), { name:newName, updatedAt:Date.now() });
        await set(roomIndexRef(newName), true);
        await remove(roomMetaRef(name)); await remove(roomIndexRef(name));
        if(session.room===name){
          session.room=newName; roomHdr.textContent=newName; roomInput.value=newName; saveLastRoom(newName);
          attachMessages(); loadUsersRealtime(); saveSession();
          if(session.isAdmin || session.num===0) { await setGlobalRoom(newName); }
        }
        toast("Sala renombrada"); reloadRooms();
      };
      row.querySelector("[data-act=delete]").onclick=async()=>{
        if(!confirm(`¬øEliminar la sala "${name}" y TODOS sus usuarios/mensajes?`)) return;
        if(!confirm("Esta acci√≥n no se puede deshacer. Confirmar borrado.")) return;
        await remove(ref(db,`rooms/${name}`)).catch(()=>{});
        await remove(roomMetaRef(name)).catch(()=>{}); await remove(roomIndexRef(name)).catch(()=>{});
        if(session.room===name){
          session.room=DEFAULT_ROOM; roomHdr.textContent=session.room; roomInput.value=session.room; saveLastRoom(session.room);
          attachMessages(); loadUsersRealtime(); saveSession();
          if(session.isAdmin || session.num===0){ await setGlobalRoom(session.room); }
        }
        toast("Sala eliminada"); reloadRooms();
      };
      roomsList.appendChild(row);
    });
  }

  roomUseBtn.onclick=async()=>{
    const newRoom=(roomInput.value||"").trim(); if(!newRoom) return toast("Escribe un nombre de sala");
    if(newRoom===session.room) return;
    session.room=newRoom; roomHdr.textContent=newRoom; saveLastRoom(newRoom); saveSession();
    attachMessages(); if(session.num===0) loadUsersRealtime();
    toast(`Sala cambiada a "${newRoom}"`);
    if(session.isAdmin || session.num===0){ await setGlobalRoom(newRoom); }
  };
  btnCreateRoom.onclick=async()=>{
    const name=(newRoomName.value||"").trim(); if(!name) return toast("Escribe un nombre para la sala");
    const exists=await get(roomMetaRef(name)); if(exists.exists()) return toast("Esa sala ya existe");
    await set(roomMetaRef(name), { name, createdAt:Date.now(), updatedAt:Date.now() });
    await set(roomIndexRef(name), true);
    toast("Sala creada"); newRoomName.value=""; reloadRooms();
  };
  btnReloadRooms.onclick=reloadRooms;

  /* ===== Gestor de usuarios ===== */
  function updateUsersAgo(){
    [...usersList.querySelectorAll("[data-uid]")].forEach(el=>{
      const uid=el.getAttribute("data-uid"); const u=usersCache[uid]; if(!u) return;
      const ago=el.querySelector(".ago"); if(ago){ const t=u.updated||u.created||Date.now(); ago.textContent="hace "+timeAgo(t); }
    });
  }
  function loadUsersRealtime(){
    if(detachUsers){ detachUsers(); detachUsers=null; }
    const r=currentRoomRef("users");
    const handler=(snap)=>{
      usersList.innerHTML="";
      const users=snap.val()||{}; usersCache=users; let connected=0;
      Object.keys(users).sort((a,b)=>Number(a)-Number(b)).forEach(k=>{
        const u=users[k]||{}; if(u.connected) connected++;
        const row=document.createElement("div"); row.setAttribute("data-uid",k); row.className="row";
        const badge=`<span class="tag ${u.connected?"ok":"bad"}">${u.connected?"conectado":"desconectado"}</span>`;
        const agoTxt=`hace ${timeAgo(u.updated||u.created||Date.now())}`;
        row.innerHTML = `<b>#${k}</b> ¬∑ PIN <span class="tag">${u.pin||"‚Äî"}</span> ${badge} <span class="sub ago">${agoTxt}</span>
          <button class="btn sm" data-a="act">Activar</button>
          <button class="btn sm danger" data-a="deact">Desactivar</button>
          <button class="btn sm danger" data-a="del">Eliminar</button>`;
        row.querySelector("[data-a=act]").onclick=()=>setEntryState(k,true);
        row.querySelector("[data-a=deact]").onclick=()=>setEntryState(k,false);
        row.querySelector("[data-a=del]").onclick=()=>deleteUser(k);
        usersList.appendChild(row);
      });
      countConn.textContent=connected;
    };
    onValue(r, handler); detachUsers=()=>off(r,"value",handler);
  }
  async function setEntryState(n, active){
    if(!/^\d+$/.test(String(n))) return toast("N√∫mero inv√°lido");
    await set(ref(db, `entradas/${n}`), { estado: active ? "activa" : "inactiva" });
    toast(active? "Usuario ACTIVADO" : "Usuario desactivado");
  }
  async function deleteUser(n){
    if(!confirm(`Eliminar usuario #${n} de la sala "${session.room}"?`)) return;
    await remove(currentRoomRef(`users/${n}`)).catch(()=>{});
    await remove(ref(db,`entradas/${n}`)).catch(()=>{});
    toast("Usuario eliminado");
  }
  btnCreateUser.onclick=async()=>{
    try{
      const n=Number((userNumber.value||"").trim()); if(!n && n!==0) return toast("N√∫mero inv√°lido");
      const pin=newPIN();
      await set(ref(db,`entradas/${n}`),{estado:"activa"});
      await set(currentRoomRef(`users/${n}`),{pin,active:true,connected:false,created:Date.now(),updated:Date.now()});
      toast(`Usuario #${n} creado ¬∑ PIN ${pin}`);
    }catch{ toast("No se pudo crear el usuario"); }
  };
  btnActivateUser.onclick=async()=>{ const n=Number((userNumber.value||"").trim()); if(!n && n!==0) return toast("N√∫mero inv√°lido"); await setEntryState(n,true); };
  btnDeactivateUser.onclick=async()=>{ const n=Number((userNumber.value||"").trim()); if(!n && n!==0) return toast("N√∫mero inv√°lido"); await setEntryState(n,false); };
  btnDeleteUser.onclick=async()=>{ const n=Number((userNumber.value||"").trim()); if(!n && n!==0) return toast("N√∫mero inv√°lido"); await deleteUser(n); };

  /* ===== Restaurar sesi√≥n y escuchar sala global ===== */
  listenGlobalRoom();

  (async function initHeaderRoom(){
    try{
      const lastRemote = await getCurrentRoomOnce();
      currentRoomCache = lastRemote;
      session.room = lastRemote || loadLastRoom() || DEFAULT_ROOM;
      roomHdr.textContent=session.room; roomInput.value=session.room;
    }catch{
      const last=loadLastRoom();
      session.room=last; roomHdr.textContent=last; roomInput.value=last;
    }
  })();

  async function tryRestoreSession(){
    const s=loadSession(); if(!s) return;
    try{
      const remoteRoom = currentRoomCache || await getCurrentRoomOnce();
      session.room = remoteRoom || s.room || loadLastRoom() || DEFAULT_ROOM;
      roomHdr.textContent=session.room; roomInput.value=session.room;

      if(s.isAdmin && String(s.num)==="0"){
        session.num=0; session.isAdmin=true; meIdHdr.textContent='0'; enterChat(true); return;
      }
      if(!await isEntryAllowed(s.num)) return clearSession();
      const data=await normalizeUserNode(session.room, s.num);
      if(!data || String(data.pin)!==String(s.pin)) return clearSession();
      await update(roomRef(session.room,`users/${s.num}`),{connected:true,updated:Date.now()});
      session.num=Number(s.num); session.isAdmin=false; numInput.value=s.num; pinInput.value=s.pin; meIdHdr.textContent=String(s.num);
      enterChat(false);
    }catch{ clearSession(); }
  }
  tryRestoreSession();

  /* ===== Ajustes menores de UX ===== */
  // Si el logo PNG falla por cach√©/ruta, no rompe nada:
  brandLogo.addEventListener('error', ()=>{ brandLogo.style.display='none'; });

  // Asegurar que composer no solapa el teclado (iOS):
  ['focus','click'].forEach(ev=>{
    msgInput.addEventListener(ev, ()=>{ setTimeout(snapToBottom, 50); });
  });
  if(vv){
    vv.addEventListener('resize', ()=>{ setTimeout(snapToBottom, 50); });
  }
  </script>
</body>
</html>

